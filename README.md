# AstGuard - Статический анализатор безопасности Python-кода

Проект представляет собой инструмент статического анализа защищенности приложений (SAST)
для кодовых баз на Python3. Анализатор осуществляет исследование исходного кода,
выявляя небезопасные конструкции, которые могут привести к возникновению уязвимостей
в промышленных системах. Используя стандартную библиотеку Python, инструмент проводит
структурный анализ для обнаружения опасных конструкций до их попадания в production среду.

Статический анализ является критически важным компонентом жизненного цикла безопасной разработки
программного обеспечения. В отличие от динамического тестирования, статический анализ исследует
структуру и логику кода без необходимости в тестовых сценариях или исполняемых окружениях,
обеспечивая раннее обнаружение проблем безопасности на этапе разработки.

Анализатор предназначен для интеграции в CI/CD-конвейеры, 
pre-commit хуки и проведения ручного аудита безопасности.
Инструмент обеспечивает детерминированные результаты на основе синтаксического
и семантического анализа исходного кода Python.

## Постановка проблемы

Python-приложения часто содержат уязвимости безопасности, возникающие через:

- **Инъекции кода**: Использование `eval()`, `exec()`, `compile()` с недоверенным вводом
- **Уязвимости десериализации**: Небезопасная десериализация объектов через модуль `pickle`
- **Инъекция команд**: Выполнение shell-команд без надлежащей проверки ввода
- **Path traversal**: Операции файловой системы с путями, контролируемыми пользователем
- **Слабая криптография**: Использование устаревших или небезопасных криптографических функций
- **Раскрытие информации**: Hardcoded credentials, отладочные функции в production-коде

Эти классы уязвимостей соответствуют записям CWE (Common Weakness Enumeration).
Ручной code review плохо масштабируется для больших кодовых баз,
что делает автоматизированный анализ критически важным для поддержания информационной безопасности.

## Архитектура и принципы работы

### Парсинг кода

Анализатор принимает на вход файлы исходного кода Python и строит абстрактное синтаксическое дерево (AST).
AST представляет структуру кода в виде иерархического дерева узлов,
где каждый узел соответствует синтаксической конструкции (вызов функции, импорт, присваивание переменной и т.д.).

### Анализ AST

Инструмент реализует паттерн visitor для обхода AST.
Каждый узел проверяется на соответствие базе правил, кодирующих знания о безопасности:

1. **Идентификация типа узла**: Определение, представляет ли узел потенциально опасную операцию (вызов функции, доступ к атрибуту, импорт)
2. **Сопоставление с паттерном**: Сравнение атрибутов узла с известными небезопасными паттернами
3. **Контекстный анализ**: Оценка окружающего кода для снижения числа ложных срабатываний
4. **Классификация severity**: Назначение уровня риска на основе эксплуатируемости и воздействия

### Система правил

Правила, отображают паттерны AST на типы уязвимостей. Каждое правило включает:
- **Определение паттерна**: Структура узла AST для сопоставления
- **Классификация уязвимости**: Маппинг на CWE и уровень критичности
- **Рекомендации по устранению**: Безопасные альтернативы
- **Контекстные условия**: Дополнительные проверки для повышения точности детектирования

Система правил расширяема, что позволяет командам безопасности определять кастомные правила
для специфичных для организации политик безопасности.

## Базовые поддерживаемые классы уязвимостей

| Тип уязвимости              | Паттерн детектирования                                                 | Референс CWE |
|-----------------------------|------------------------------------------------------------------------|--------------|
| Code Injection              | `eval()`, `exec()`, `compile()`                                        | CWE-94       |
| Command Injection           | `os.system()`, `subprocess.*`                                          | CWE-78       |
| Deserialization             | `pickle.loads()`, `pickle.load()`, `yaml.unsafe_load()`, `yaml.load()` | CWE-502      |
| Path Traversal              | `open()`, `os.path.join()`                                             | CWE-22       |
| Weak Cryptography           | `hashlib.md5()`, `hashlib.sha1()`                                      | CWE-327      |
| Hardcoded Credentials       | Переменные с именами `password`, `token` и др.                         | CWE-798      |
| Debug Features              | Вызовы с аргументом `debug=True`                                       | CWE-489      |
| SQL Injection               | Метод `.execute()` с динамическими строками                            | CWE-89       |
| XML External Entities (XXE) | `xml.etree.ElementTree`, `lxml.etree`                                  | CWE-611      |

## Пример обнаруженной уязвимости

Рассмотрим следующий Python-код:

```python
import os
import pickle

def process_user_command(user_input):
    # Уязвимость Command Injection
    os.system(f"ls {user_input}")

def load_user_data(data):
    # Уязвимость Deserialization
    return pickle.loads(data)

def calculate(expression):
    # Уязвимость Code Injection
    return eval(expression)
```

**Вывод анализатора:**

```
[HIGH] Command Injection (CWE-78) в example.py:6
  Функция: process_user_command
  Паттерн: os.system
  Риск: Инъекция shell-команды через параметры
  Рекомендация: Использовать subprocess.run() с shell=False и списком аргументов

[HIGH] Deserialization (CWE-502) в example.py:10
  Функция: load_user_data
  Паттерн: pickle.loads
  Риск: Выполнение произвольного кода при десериализации
  Рекомендация: Использовать JSON или другой безопасный формат сериализации

[HIGH] Code Injection (CWE-94) в example.py:14
  Функция: calculate
  Паттерн: eval
  Риск: Выполнение произвольного кода
  Рекомендация: Использовать ast.literal_eval() для безопасного вычисления литералов
```

Каждая находка содержит точное местоположение, классификацию уязвимости и рекомендации по устранению.


### Модель безопасности

Анализатор работает исходя из предположений:
- Весь внешний ввод по умолчанию не является доверенным
- Определённые API-вызовы по своей природе опасны независимо от контекста
- Намерения разработчика могут отличаться от поведения кода

Инструмент разработан для дополнения, а не замены ручной проверки, динамического тестирования.

## Установка и использование

### Быстрая установка

#### Универсальный способ (через pip)
Вы можете установить `astguard` напрямую из GitHub:
```bash
pip install git+https://github.com/mrzkv/astguard.git
```
*Примечание: В некоторых системах Linux может потребоваться флаг `--break-system-packages` или использование `pipx`.*

#### Linux и macOS (Bash)
Для установки одной командой (через скрипт):
```bash
curl -sSL https://raw.githubusercontent.com/mrzkv/astguard/main/install.sh | bash
```

#### Windows (PowerShell)
Выполните в PowerShell (от имени администратора):
```powershell
irm https://raw.githubusercontent.com/mrzkv/astguard/main/install.ps1 | iex
```

### Требования

- Python 3.8 или выше
- Git (для установки из репозитория)

### Установка

1. Склонируйте репозиторий:
```bash
git clone https://github.com/mrzkv/astguard.git
cd astguard
```

2. Установите проект:
```bash
# Через pip (простейший способ)
pip install .

# Или через uv (рекомендуется)
uv pip install .
```

После установки утилита будет доступна по команде `astguard`.

### Использование

```bash
# Анализ текущей директории
astguard .

# Анализ конкретного файла
astguard path/to/script.py

# Вывод краткого отчета (одна строка на находку)
astguard . --short
```

### Настройка

Вы можете настроить поведение анализатора с помощью файла `.astguardignore` или `pyproject.toml`.

#### Использование .astguardignore
Создайте файл `.astguardignore` в корневом каталоге проекта для исключения определенных файлов или директорий из анализа. Формат аналогичен `.gitignore`:
- Пустые строки и строки, начинающиеся с `#`, игнорируются.
- Поддерживаются простые паттерны имен файлов и директорий.

#### Использование pyproject.toml
Вы можете перенести настройки в файл `pyproject.toml`. Поддерживаются следующие опции в секции `[tool.astguard]`:

```toml
[tool.astguard]
# Список файлов и директорий для анализа
include = [
    "src",
    "app"
]

# Список исключаемых файлов и директорий (аналогично .astguardignore)
exclude = [
    "tests/*",
    "setup.py",
    "legacy_code.py"
]

# Список игнорируемых CWE (эти проверки будут отключены глобально)
ignore = [
    "CWE-489", # Debug Features
    "CWE-327"  # Weak Cryptography
]
```

#### Внутристрочное игнорирование (Inline ignores)
Вы можете игнорировать конкретные срабатывания прямо в коде, добавив комментарий в конец строки:

```python
os.system(cmd)  # noqa
eval(payload)   # astguard: ignore
os.system(cmd)  # noqa: CWE-78
eval(payload)   # astguard: ignore CWE-94
```

Поддерживаются форматы:
- `# noqa` или `# astguard: ignore` — игнорировать все уязвимости на этой строке.
- `# noqa: CWE-78` или `# astguard: ignore CWE-78` — игнорировать только указанную CWE.

### Дополнительные возможности

```bash
# Просмотр версии
astguard --version

# Справка по командам
astguard --help
```

### Коды завершения

- `0`: Уязвимости не обнаружены
- `1`: Уязвимости найдены
- `2`: Ошибка анализа (некорректный синтаксис Python, файл не найден)

### Разработка и запуск из исходников

Если вы вносите изменения в код и хотите запустить их без переустановки:
```bash
python3 -m astguard.main .
```

### Интеграция в CI/CD

```bash
# Провал сборки при обнаружении проблем уровня HIGH
astguard src/ --short
```

### Создатель:
- [mrzkv](https://tg.mrzkv.ru)