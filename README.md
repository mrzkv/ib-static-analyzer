# Статический анализатор безопасности Python-кода

## Описание

Проект представляет собой инструмент статического анализа защищенности приложений (SAST) для кодовых баз на Python. Анализатор осуществляет исследование исходного кода без его выполнения, выявляя небезопасные конструкции, которые могут привести к возникновению уязвимостей в промышленных системах. Используя модуль Abstract Syntax Tree (AST) из стандартной библиотеки Python, инструмент проводит структурный анализ для обнаружения опасных конструкций до их попадания в runtime-окружение.

Статический анализ является критически важным компонентом жизненного цикла безопасной разработки программного обеспечения. В отличие от динамического тестирования, статический анализ исследует структуру и логику кода без необходимости в тестовых сценариях или исполняемых окружениях, обеспечивая раннее обнаружение проблем безопасности на этапе разработки. Данный подход сокращает поверхность атаки путём выявления и устранения небезопасных паттернов до развёртывания системы.

Анализатор предназначен для интеграции в CI/CD-конвейеры, pre-commit хуки и проведения ручного аудита безопасности. Инструмент обеспечивает детерминированные результаты на основе синтаксического и семантического анализа исходного кода Python.

## Постановка проблемы

Современные Python-приложения часто содержат уязвимости безопасности, возникающие через:

- **Векторы инъекции кода**: Использование `eval()`, `exec()`, `compile()` с недоверенным вводом
- **Уязвимости десериализации**: Небезопасная десериализация объектов через модуль `pickle`
- **Инъекция команд**: Выполнение shell-команд без надлежащей санитизации ввода
- **Path traversal**: Операции файловой системы с путями, контролируемыми пользователем
- **Слабая криптография**: Использование устаревших или небезопасных криптографических примитивов
- **Раскрытие информации**: Hardcoded credentials, отладочные функции в production-коде

Эти классы уязвимостей соответствуют записям CWE (Common Weakness Enumeration) и рискам безопасности OWASP. Ручной code review плохо масштабируется для больших кодовых баз, что делает автоматизированный статический анализ критически важным для поддержания security posture.

## Архитектура и принципы работы

### Парсинг кода

Анализатор принимает на вход файлы исходного кода Python и строит абстрактное синтаксическое дерево (AST) с использованием модуля `ast` из стандартной библиотеки. AST представляет структуру кода в виде иерархического дерева узлов, где каждый узел соответствует синтаксической конструкции (вызов функции, импорт, присваивание переменной и т.д.).

### Анализ AST

Инструмент реализует паттерн visitor для обхода AST. Каждый узел проверяется на соответствие базе правил, кодирующих знания о безопасности:

1. **Идентификация типа узла**: Определение, представляет ли узел потенциально опасную операцию (вызов функции, доступ к атрибуту, импорт)
2. **Сопоставление с паттерном**: Сравнение атрибутов узла с известными небезопасными паттернами
3. **Контекстный анализ**: Оценка окружающего кода для снижения числа ложных срабатываний
4. **Классификация severity**: Назначение уровня риска на основе эксплуатируемости и воздействия

### Система правил

Правила определены как декларативные спецификации, отображающие паттерны AST на типы уязвимостей. Каждое правило включает:

- **Определение паттерна**: Структура узла AST для сопоставления
- **Классификация уязвимости**: Маппинг на CWE и уровень критичности
- **Рекомендации по устранению**: Безопасные альтернативы
- **Контекстные условия**: Дополнительные проверки для повышения точности детектирования

Система правил расширяема, что позволяет командам безопасности определять кастомные правила для специфичных для организации политик безопасности.

## Поддерживаемые классы уязвимостей

| Тип уязвимости | Паттерн детектирования | Референс CWE |
|----------------|------------------------|--------------|
| Code Injection | `eval()`, `exec()`, `compile()` | CWE-94 |
| Command Injection | `os.system()`, `subprocess.*` | CWE-78 |
| Deserialization | `pickle.loads()`, `pickle.load()`, `yaml.unsafe_load()`, `yaml.load()` | CWE-502 |
| Path Traversal | `open()`, `os.path.join()` | CWE-22 |
| Weak Cryptography | `hashlib.md5()`, `hashlib.sha1()` | CWE-327 |
| Hardcoded Credentials | Переменные с именами `password`, `token` и др. | CWE-798 |
| Debug Features | Вызовы с аргументом `debug=True` | CWE-489 |
| SQL Injection | Метод `.execute()` с динамическими строками | CWE-89 |
| XML External Entities (XXE) | `xml.etree.ElementTree`, `lxml.etree` | CWE-611 |

## Пример обнаруженной уязвимости

Рассмотрим следующий Python-код:

```python
import os
import pickle

def process_user_command(user_input):
    # Уязвимость Command Injection
    os.system(f"ls {user_input}")

def load_user_data(data):
    # Уязвимость Deserialization
    return pickle.loads(data)

def calculate(expression):
    # Уязвимость Code Injection
    return eval(expression)
```

**Вывод анализатора:**

```
[HIGH] Command Injection (CWE-78) в example.py:6
  Функция: process_user_command
  Паттерн: os.system
  Риск: Инъекция shell-команды через параметры
  Рекомендация: Использовать subprocess.run() с shell=False и списком аргументов

[HIGH] Deserialization (CWE-502) в example.py:10
  Функция: load_user_data
  Паттерн: pickle.loads
  Риск: Выполнение произвольного кода при десериализации
  Рекомендация: Использовать JSON или другой безопасный формат сериализации

[HIGH] Code Injection (CWE-94) в example.py:14
  Функция: calculate
  Паттерн: eval
  Риск: Выполнение произвольного кода
  Рекомендация: Использовать ast.literal_eval() для безопасного вычисления литералов
```

Каждая находка содержит точное местоположение, классификацию уязвимости, объяснение threat model и действенные рекомендации по устранению.

## Ограничения и допущения

### Границы применимости

- **Только статический анализ**: Не выполняет код и не анализирует runtime-поведение
- **Детектирование на основе AST**: Не может обнаружить уязвимости в динамически генерируемом коде
- **Ложные срабатывания**: Может помечать безопасный код, выглядящий синтаксически опасным
- **Пропуски уязвимостей**: Не может обнаружить все экземпляры уязвимостей, особенно контекстно-зависимые проблемы

### Известные ограничения

1. **Базовый Data Flow Analysis**: Поддержка отслеживания распространения недоверенных данных (taint tracking) через переменные и строковые операции.
2. **Базовый Inter-procedural Analysis**: Двухпроходный анализ для выявления пользовательских функций, передающих данные в опасные sink-функции.
3. **Отсутствие выведения типов**: Анализатор не выводит типы для динамически типизированных переменных.
4. **Отсутствие runtime-контекста**: Не может определить фактическую достижимость пути кода во время выполнения.
5. **Ограниченная криптографическая валидация**: Проверка только по паттернам использования известных слабых алгоритмов.

### Модель безопасности

Анализатор работает исходя из предположений:
- Весь внешний ввод по умолчанию не является доверенным
- Определённые API-вызовы по своей природе опасны независимо от контекста
- Намерения разработчика могут отличаться от поведения кода

Инструмент разработан для дополнения, а не замены ручного security review, динамического тестирования и penetration testing.

## Установка и использование

### Требования

- Python 3.13 или выше
- Утилита `uv` (рекомендуется) или `pip`

### Установка

1. Склонируйте репозиторий:
```bash
git clone <repository-url>
cd ib-static-analyzer
```

2. Установите проект в систему (или виртуальное окружение):
```bash
# Использование uv (рекомендуется)
uv pip install -e .

# Или через pip
pip install -e .
```

После установки утилита будет доступна по команде `astguard`.

### Использование

```bash
# Анализ текущей директории
astguard .

# Анализ конкретного файла
astguard path/to/script.py

# Вывод краткого отчета (одна строка на находку)
astguard . --short
```

### Настройка

Вы можете настроить поведение анализатора с помощью файла `.astguardignore` или `pyproject.toml`.

#### Использование .astguardignore
Создайте файл `.astguardignore` в корневом каталоге проекта для исключения определенных файлов или директорий из анализа. Формат аналогичен `.gitignore`:
- Пустые строки и строки, начинающиеся с `#`, игнорируются.
- Поддерживаются простые паттерны имен файлов и директорий.

#### Использование pyproject.toml
Вы можете перенести настройки в файл `pyproject.toml`. Поддерживаются следующие опции в секции `[tool.astguard]`:

```toml
[tool.astguard]
# Список файлов и директорий для анализа
include = [
    "src",
    "app"
]

# Список исключаемых файлов и директорий (аналогично .astguardignore)
exclude = [
    "tests/*",
    "setup.py",
    "legacy_code.py"
]

# Список игнорируемых CWE (эти проверки будут отключены глобально)
ignore = [
    "CWE-489", # Debug Features
    "CWE-327"  # Weak Cryptography
]
```

#### Внутристрочное игнорирование (Inline ignores)
Вы можете игнорировать конкретные срабатывания прямо в коде, добавив комментарий в конец строки:

```python
os.system(cmd)  # noqa
eval(payload)   # astguard: ignore
os.system(cmd)  # noqa: CWE-78
eval(payload)   # astguard: ignore CWE-94
```

Поддерживаются форматы:
- `# noqa` или `# astguard: ignore` — игнорировать все уязвимости на этой строке.
- `# noqa: CWE-78` или `# astguard: ignore CWE-78` — игнорировать только указанную CWE.

### Дополнительные возможности

```bash
# Просмотр версии
astguard --version

# Справка по командам
astguard --help
```

### Коды завершения

- `0`: Уязвимости не обнаружены
- `1`: Уязвимости найдены
- `2`: Ошибка анализа (некорректный синтаксис Python, файл не найден)

### Разработка и запуск из исходников

Если вы вносите изменения в код и хотите запустить их без переустановки:
```bash
python3 -m astguard.main .
```

### Интеграция в CI/CD

```bash
# Провал сборки при обнаружении проблем уровня HIGH
astguard src/ --short
```

## Возможные направления развития

### Краткосрочные улучшения

- **Расширенный Taint analysis**: Отслеживание потока данных через сложные структуры (словари, списки)
- **Профили конфигурации**: Определение порогов severity и наборов правил для разных окружений
- **Поддержка baseline**: Механизм подавления известных проблем для фокуса на новых уязвимостях
- **Интеграция с IDE**: Плагины для предоставления обратной связи в реальном времени

### Долгосрочные направления исследований

- **Deep Inter-procedural analysis**: Анализ многоуровневых цепочек вызовов между модулями
- **Улучшенное выведение типов**: Использование type hints и статической типизации для снижения False Positives
- **Machine learning**: Распознавание паттернов для обнаружения аномалий в коде
- **Symbolic execution**: Анализ путей выполнения для проверки достижимости уязвимостей
- **Framework-специфичные правила**: Глубокая интеграция с моделями безопасности Django, Flask, FastAPI

### Вклад сообщества

Потенциальные области для расширения:
- Определение кастомных правил для domain-специфичных политик безопасности
- Интеграция с базами данных уязвимостей (CVE, NVD)
- Оптимизация производительности для крупномасштабных кодовых баз
- Поддержка дополнительных языков через AST-адаптеры

## Лицензия

MIT License

Copyright (c) 2025

Данная лицензия разрешает любому лицу, получившему копию данного программного обеспечения
и сопутствующей документации (в дальнейшем именуемыми «Программное Обеспечение»),
безвозмездно использовать Программное Обеспечение без ограничений, включая неограниченное
право на использование, копирование, изменение, слияние, публикацию, распространение,
сублицензирование и/или продажу копий Программного Обеспечения, а также лицам, которым
предоставляется данное Программное Обеспечение, при соблюдении следующих условий:

Указанное выше уведомление об авторском праве и данные условия должны быть включены во
все копии или значимые части данного Программного Обеспечения.

ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ «КАК ЕСТЬ», БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ,
ЯВНО ВЫРАЖЕННЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ ГАРАНТИИ ТОВАРНОЙ ПРИГОДНОСТИ,
СООТВЕТСТВИЯ ПО ЕГО КОНКРЕТНОМУ НАЗНАЧЕНИЮ И ОТСУТСТВИЯ НАРУШЕНИЙ, НО НЕ ОГРАНИЧИВАЯСЬ
ИМИ. НИ В КАКОМ СЛУЧАЕ АВТОРЫ ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ПО КАКИМ-ЛИБО
ИСКАМ, ЗА УЩЕРБ ИЛИ ПО ИНЫМ ТРЕБОВАНИЯМ, В ТОМ ЧИСЛЕ, ПРИ ДЕЙСТВИИ КОНТРАКТА, ДЕЛИКТЕ
ИЛИ ИНОЙ СИТУАЦИИ, ВОЗНИКШИМ ИЗ-ЗА ИСПОЛЬЗОВАНИЯ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ ИЛИ ИНЫХ
ДЕЙСТВИЙ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ.
